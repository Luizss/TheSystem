{-# LANGUAGE ViewPatterns #-}

module Project where

import Data
import Data.List hiding (cycle)
import Data.Time hiding (toGregorian, fromGregorian)
import Data.DateTime hiding (getCurrentTime)

commandType :: Command -> CommandType
commandType comm = case comm of
  CycleC _ _            -> C

  DurationC _           -> D
  DurationsC _          -> D
  DurationsiC _         -> D'
  DurationsnC _         -> D
  DurationsniC _        -> D'
  
  DivisionC _           -> D
  DivisionnC _          -> D
  DivisionsC _          -> D
  DivisionsiC _         -> D'
  DivisionsnC _         -> D
  DivisionsniC _        -> D'
  DivisionsnnC _        -> D
  DivisionsnniC _       -> D'
  
  TodayC                -> E
  EndpointC _           -> E
  
  TotaltimeC _          -> T
  EffectiveTotaltimeC _ -> T
  
  NotinC _              -> ICons
  InC _                 -> ICons
  NotbeginC _           -> ICons
  BeginC _              -> ICons
  NotendC _             -> ICons
  EndC _                -> ICons
  
  AfterC _              -> ConsT
  BeforeC _             -> ConsT
  RightafterC _         -> ConsT
  RightbeforeC _        -> ConsT
  
  AtC _                 -> PlaceT
  
  MsgC _                -> MsgT
  MsgsC _               -> MsgT

projectType :: [Command] -> ProjectType
projectType = projectTypeFromCommandTypes . map commandType

projectTypeFromCommandTypes :: [CommandType] -> ProjectType
projectTypeFromCommandTypes cst = case sort cst of
  C : D : E : T : s -> check CDET_  s
  C : D': E : T : s -> check CD'ET_ s
  C : D : E : s     -> check CDE_   s
  C : D': E : s     -> check CD'E_  s
  C : D : T : s     -> check CDT_   s
  C : D': T : s     -> check CD'T_  s
  C : E : T : s     -> check CET_   s
  D : E : T : s     -> check DET_   s
  D': E : T : s     -> check D'ET_  s
  C : D : s         -> check CD_    s
  C : D': s         -> check CD'_   s
  D : E : s         -> check DE_    s
  C : E : s         -> check CE_    s
  E : T : s         -> check ET_    s
  C : T : s         -> check CT_    s
  _                 -> error "Project not well defined."

-- talvez usar lista em has seja desnecessario
check :: ProjectType -> [CommandType] -> ProjectType
check CD_    cs = if has [D,D'] cs then errDup else CD_
check CD'_   cs = if has [D,D'] cs then errDup else CD'_
check DE_    cs = if has [E] cs then errDup else DE_
check CE_    cs = if has [E] cs then errDup else CE_
check ET_    cs = if has [T] cs then errDup else ET_
check CT_    cs = if has [T] cs then errDup else CT_
check CDE_   cs = if has [E] cs then errDup else CDE_
check CD'E_  cs = if has [E] cs then errDup else CD'E_
check CDT_   cs = if has [T] cs then errDup else CDT_
check CD'T_  cs = if has [T] cs then errDup else CD'T_
check CET_   cs = if has [T] cs then errDup else CET_
check DET_   cs = if has [T] cs then errDup else DET_
check D'ET_  cs = if has [T] cs then errDup else D'ET_
check CDET_  cs = if has [T] cs then errDup else CDET_
check CD'ET_ cs = if has [T] cs then errDup else CD'ET_

sort' :: [Command] -> [Command]
sort' cs =
  map fst
  $ sortBy (\(_,t) (_,t') -> compare t t')
  $ zip cs (map commandType cs)
           
makeProject :: [Command] -> IO Project
makeProject (sort' -> cs) = case projectType cs of
   CD_    -> do
     as <- addOns (drop 2 cs) 
     return $ CD
       (cycl (cs !! 0))
       (duration (cs !! 1))
       as
   CD'_   -> do
     as <- addOns (drop 2 cs) 
     return $ CD'
       (cycl (cs !! 0))
       (duration' (cs !! 1))
       as
   DE_    -> do
     e <- endpoint (cs !! 1)
     as <- addOns (drop 2 cs) 
     return $ DE
       (duration (cs !! 0))
       e
       as
   CE_    -> do
     e <- endpoint (cs !! 1)
     as <- addOns (drop 2 cs) 
     return $ CE
       (cycl (cs !! 0))
       e
       as
   ET_    -> do
     e <- endpoint (cs !! 0)
     as <- addOns (drop 2 cs) 
     return $ ET
       e
       (totaltime (cs !! 1))
       as
   CT_    -> do
     as <- addOns (drop 2 cs) 
     return $ CT
       (cycl (cs !! 0))
       (totaltime (cs !! 1))
       as
   CDE_   -> do
     e <- endpoint (cs !! 2)
     as <- addOns (drop 3 cs) 
     return $ CDE
       (cycl (cs !! 0))
       (duration (cs !! 1))
       e
       as
   CD'E_  -> do
     e <- endpoint (cs !! 2)
     as <- addOns (drop 3 cs) 
     return $ CD'E
       (cycl (cs !! 0))
       (duration' (cs !! 1))
       e
       as
   CDT_   -> do
     as <- addOns (drop 3 cs)
     return $ CDT
       (cycl (cs !! 0))
       (duration (cs !! 1))
       (totaltime (cs !! 2))
       as
   CD'T_  -> do
     as <- addOns (drop 3 cs) 
     return $ CD'T
       (cycl (cs !! 0))
       (duration' (cs !! 1))
       (totaltime (cs !! 2))
       as
   CET_   -> do
     e <- endpoint (cs !! 1)
     as <- addOns (drop 3 cs) 
     return $ CET
       (cycl (cs !! 0))
       e
       (totaltime (cs !! 2))
       as
   DET_   -> do
     e <- endpoint (cs !! 1)
     as <- addOns (drop 3 cs) 
     return $ DET
       (duration (cs !! 0))
       e
       (totaltime (cs !! 2))
       as
   D'ET_  -> do
     e <- (endpoint (cs !! 1))
     as <- addOns (drop 3 cs) 
     return $ D'ET
       (duration' (cs !! 0))
       e
       (totaltime (cs !! 2))
       as
   CDET_  -> do
     e <- endpoint (cs !! 2)
     as <- addOns (drop 4 cs) 
     return $ CDET
       (cycl (cs !! 0))
       (duration (cs !! 1))
       e
       (totaltime (cs !! 3))
       as
   CD'ET_ -> do
     e <- endpoint (cs !! 2)
     as <- addOns (drop 4 cs) 
     return $ CD'ET
       (cycl (cs !! 0))
       (duration' (cs !! 1))
       e
       (totaltime (cs !! 3))
       as

makeProject' :: [Command] -> IO Project'
makeProject' (sort' -> cs) = case projectType cs of
   CD_    -> do
     let c = cycl (cs !! 0)
         d = duration (cs !! 1)
     as <- addOns (drop 2 cs)
     return $ Project'
       (Just c)
       (Just d)
       Nothing
       Nothing
       as
   CD'_   -> do
     let c = cycl (cs !! 0)
         d = duration' (cs !! 1)
     as <- addOns (drop 2 cs)
     return $ Project'
       (Just c)
       (Just d)
       Nothing
       Nothing
       as
   DE_    -> do
     let d = duration (cs !! 0)
     e  <- endpoint (cs !! 1)
     as <- addOns (drop 2 cs)
     return $ Project'
       Nothing
       (Just d)
       (Just e)
       Nothing
       as
   CE_    -> do
     let c = cycl (cs !! 0)
     e  <- endpoint (cs !! 1)
     as <- addOns (drop 2 cs)
     return $ Project'
       (Just c)
       Nothing
       (Just e)
       Nothing
       as
   ET_    -> do
     e <- endpoint (cs !! 0)
     let t = totaltime (cs !! 1)
     as <- addOns (drop 2 cs) 
     return $ Project'
       Nothing
       Nothing
       (Just e)
       (Just t)
       as
   CT_    -> do
     let c = cycl (cs !! 0)
         t = totaltime (cs !! 1)
     as <- addOns (drop 2 cs) 
     return $ Project'
       (Just c)
       Nothing
       Nothing
       (Just t)
       as
   CDE_   -> do
     let c = cycl (cs !! 0)
         d = duration (cs !! 1)
     e <- endpoint (cs !! 2)
     as <- addOns (drop 3 cs) 
     return $ Project'
       (Just c)
       (Just d)
       (Just e)
       Nothing
       as
   CD'E_  -> do
     let c = cycl (cs !! 0)
         d = duration' (cs !! 1)
     e <- endpoint (cs !! 2)
     as <- addOns (drop 3 cs) 
     return $ Project'
       (Just c)
       (Just d)
       (Just e)
       Nothing
       as
   CDT_   -> do
     let c = cycl (cs !! 0)
         d = duration (cs !! 1)
         t = totaltime (cs !! 2)
     as <- addOns (drop 3 cs)
     return $ Project'
       (Just c)
       (Just d)
       Nothing
       (Just t)
       as
   CD'T_  -> do
     let c = cycl (cs !! 0)
         d = duration (cs !! 1)
         t = totaltime (cs !! 2)
     as <- addOns (drop 3 cs) 
     return $ Project'
       (Just c)
       (Just d)
       Nothing
       (Just t)
       as
   CET_   -> do
     let c = cycl (cs !! 0)
     e <- endpoint (cs !! 1)
     let t = totaltime (cs !! 2)
     as <- addOns (drop 3 cs) 
     return $ Project'
       (Just c)
       Nothing
       (Just e)
       (Just t)
       as
   DET_   -> do
     let d = duration (cs !! 0)
     e <- endpoint (cs !! 1)
     let t = totaltime (cs !! 2)
     as <- addOns (drop 3 cs) 
     return $ Project'
       Nothing
       (Just d)
       (Just e)
       (Just t)
       as
   D'ET_  -> do
     let d = duration' (cs !! 0)
     e <- endpoint (cs !! 1)
     let t = totaltime (cs !! 2)
     as <- addOns (drop 3 cs) 
     return $ Project'
       Nothing
       (Just d)
       (Just e)
       (Just t)
       as
   CDET_  -> do
     let c = cycl (cs !! 0)
         d = duration (cs !! 1)
     e <- endpoint (cs !! 2)
     let t = totaltime (cs !! 3)
     as <- addOns (drop 4 cs) 
     return $ Project'
       (Just c)
       (Just d)
       (Just e)
       (Just t)
       as
   CD'ET_ -> do
     let c =  cycl (cs !! 0)
         d =  duration' (cs !! 1)
     e <- endpoint (cs !! 2)
     let t = totaltime (cs !! 3)
     as <- addOns (drop 4 cs) 
     return $ Project'
       (Just c)
       (Just d)
       (Just e)
       (Just t)
       as

cycl :: Command -> Cycle
cycl (CycleC num time) = Cycle num (timeToDiff time)
cycl _ = error "cycl: Wrong command type."

duration :: Command -> Duration
duration comm = Duration $ case comm of
  DurationC tim ->
    [(Nothing,[(Nothing, tim, NoInterval)])]
  DurationsC tims ->
    map
    (\tim -> (Nothing, [(Nothing, tim, NoInterval)]))
    tims
  DurationsnC nameNtims ->
    map
    (\(name,tim) -> (Just name, [(Nothing, tim, NoInterval)]))
    nameNtims
  DivisionC timNints ->
    [(Nothing, map (\(tim,int) -> (Nothing, tim, int)) timNints)]
  DivisionnC nameNtimNints ->
    [(Nothing, map (\(n,t,i) -> (Just n,t,i)) nameNtimNints)]
  DivisionsC timNintsList ->
    map
    (\timNints ->
      (Nothing,
       map
       (\(tim,int) -> (Nothing,tim,int))
       timNints))
    timNintsList
  DivisionsnC nameNtimNintsList ->
    map
    (\nameNtimNints ->
      (Nothing,
       map
       (\(name,tim,int) -> (Just name,tim,int))
       nameNtimNints))
    nameNtimNintsList
  DivisionsnnC nameNtimNintsList ->
    map
    (\(name,nameNtimNints) ->
      (Just name,
       map
       (\(name',tim,int) -> (Just name',tim,int))
       nameNtimNints))
    nameNtimNintsList
  _ -> error "duration: Wrong command type."

duration' :: Command -> Duration
duration' comm = Duration $ cycle $ case comm of
  DurationsiC tims ->
    map
    (\tim -> (Nothing, [(Nothing, tim, NoInterval)]))
    tims
  DurationsniC nameNtims ->
    map
    (\(name,tim) -> (Just name, [(Nothing, tim, NoInterval)]))
    nameNtims
  DivisionsiC timNintsList ->
    map
    (\timNints ->
      (Nothing,
       map
       (\(tim,int) -> (Nothing,tim,int))
       timNints))
    timNintsList
  DivisionsniC nameNtimNintsList ->
    map
    (\nameNtimNints ->
      (Nothing,
       map
       (\(name,tim,int) -> (Just name,tim,int))
       nameNtimNints))
    nameNtimNintsList
  DivisionsnniC nameNtimNintsList ->
    map
    (\(name,nameNtimNints) ->
      (Just name,
       map
       (\(name',tim,int) -> (Just name',tim,int))
       nameNtimNints))
    nameNtimNintsList
  _ -> error "duration': Wrong command type."

endpoint :: Command -> IO Endpoint
endpoint (EndpointC inst) = Endpoint <$> case inst of
  PutYearAndMonth date -> putYearAndMonth date
  PutYear         date -> putYear date
  PutToday        date -> putToday date
  CompleteTime    date -> return date
endpoint TodayC = Endpoint <$> today
endpoint _ = error "endpoint: Wrong command type."

totaltime :: Command -> Totaltime
totaltime (TotaltimeC          time) =
  Totaltime $ timeToDiff time
totaltime (EffectiveTotaltimeC time) =
  EffectiveTotaltime $ timeToDiff time
totaltime _ = error "totaltime: Wrong command type."

addOns :: [Command] -> IO AddOns
addOns cmds = AddOns <$> mapM addOn cmds

addOn :: Command -> IO AddOn
addOn comm = case commandType comm of
  ICons  -> IntervalConstraint <$> iCons comm
  ConsT  -> Constraint <$> (return $ constr comm)
  PlaceT -> Place      <$> (return $ place  comm)
  MsgT   -> Messg      <$> (return $ messg  comm)
  CosT   -> Cost       <$> (return $ cost   comm)

iCons :: Command -> IO IntervalConstraint
iCons = undefined
{-
iCons (InitC inst) = Init <$> case inst of
  PutYearAndMonth date -> putYearAndMonth date
  PutYear         date -> putYear date
  PutToday        date -> putToday date
  CompleteTime    date -> return date
iCons (EndC  inst) = End  <$> case inst of
  PutYearAndMonth date -> putYearAndMonth date
  PutYear         date -> putYear date
  PutToday        date -> putToday date
  CompleteTime    date -> return date
--iCons RightaftersleepC  = return Rightbeforesleep
--iCons RightbeforesleepC = return Rightbeforesleep
iCons (NotinC int) = Notin <$> notinProcess int -}

constr :: Command -> Constraint
constr comm = case comm of
  AfterC       name -> After       name
  BeforeC      name -> Before      name
  RightafterC  name -> RightAfter  name
  RightbeforeC name -> RightBefore name

place :: Command -> Place
place (AtC plc) = At plc

messg :: Command -> Messg
messg comm = case comm of
  MsgC  txt  -> Msg  txt
  MsgsC txts -> Msgs txts

cost :: Command -> Cost
cost = Cst

notinProcess :: [Interval Instant] -> IO [Interval ZonedTime]
notinProcess = mapM intervalProcess
  where
    intervalProcess :: Interval Instant -> IO (Interval ZonedTime)
    intervalProcess (FromTo from to)
      = FromTo <$> i2z from <*> i2z to
    intervalProcess (OrMore t) = OrMore <$> i2z t
    intervalProcess (Exact  t) = Exact <$> i2z t
    intervalProcess NoInterval = return NoInterval
    i2z :: Instant -> IO ZonedTime
    i2z = instantToZonedTime
    
------------------------- Helpers

errDup = error "Duplicated cycle, duration, endpoint or totaltime."

has :: [CommandType] -> [CommandType] -> Bool
has s [] = False
has s cs = or $ map (\g -> or $ map (==g) cs) s

putToday :: ZonedTime -> IO ZonedTime
putToday time = do
  ZonedTime _ timeZone@(TimeZone mins _ _) <- getZonedTime
  date <- getCurrentTime
  let (y,mo,d) = toGregorian' date
      (_,_,_,h,m,s) = toGregorian $ zonedTimeToUTC time
  return
    $ utcToZonedTime timeZone
    $ fromGregorian y mo d h (m-mins) s

putYearAndMonth :: ZonedTime -> IO ZonedTime
putYearAndMonth time = do
  ZonedTime _ timeZone@(TimeZone mins _ _) <- getZonedTime
  date <- getCurrentTime
  let (y,mo,_) = toGregorian' date
      (_,_,d,h,m,s) = toGregorian $ zonedTimeToUTC time
  return
    $ utcToZonedTime timeZone
    $ fromGregorian y mo d h (m-mins) s

putYear :: ZonedTime -> IO ZonedTime
putYear time = do
  ZonedTime _ timeZone@(TimeZone mins _ _) <- getZonedTime
  date <- getCurrentTime
  let (y,_,_) = toGregorian' date
      (_,mo,d,h,m,s) = toGregorian $ zonedTimeToUTC time
  return
    $ utcToZonedTime timeZone
    $ fromGregorian y mo d h (m-mins) s

today :: IO ZonedTime
today = do
  ZonedTime _ timeZone@(TimeZone mins _ _) <- getZonedTime
  timeUTC <- getCurrentTime
  let (y,m,d) = toGregorian' timeUTC
  return
    $ utcToZonedTime timeZone
    $ fromGregorian y m (d+1) 0 (-mins) 0

timeToDiff :: Dur -> SecondsTime
timeToDiff (Minutes  m) = m*60
timeToDiff (Hours    h) = h*3600
timeToDiff (Days     d) = d*86400
timeToDiff (Weeks    w) = w*604800
timeToDiff (Months  mo) = mo*18144000

instantToZonedTime :: Instant -> IO ZonedTime
instantToZonedTime inst = case inst of
   PutYear z         -> putYearInitial z
   PutYearAndMonth z -> putYearAndMonthInitial z
   PutToday z        -> putDayInitial z
   CompleteTime z    -> return z

putYearInitial ::  ZonedTime -> IO ZonedTime
putYearInitial z = do
  ZonedTime _ timeZone@(TimeZone mins _ _) <- getZonedTime
  let (_,mo,d,h,m,s) = toGregorian $ zonedTimeToUTC z
  return
    $ utcToZonedTime timeZone
    $ fromGregorian 1 mo d h (m-mins) s

putYearAndMonthInitial ::  ZonedTime -> IO ZonedTime
putYearAndMonthInitial z = do
  ZonedTime _ timeZone@(TimeZone mins _ _) <- getZonedTime
  let (_,_,d,h,m,s) = toGregorian $ zonedTimeToUTC z
  return
    $ utcToZonedTime timeZone
    $ fromGregorian 1 1 d h (m-mins) s

putDayInitial ::  ZonedTime -> IO ZonedTime
putDayInitial z = do
  ZonedTime _ timeZone@(TimeZone mins _ _) <- getZonedTime
  let (_,_,_,h,m,s) = toGregorian $ zonedTimeToUTC z
  return
    $ utcToZonedTime timeZone
    $ fromGregorian 1 1 1 h (m-mins) s

{----- TODO

Arrumar os tempos para que todos os tempos fiquem certos
de acordo com a zona e nao com o UTC - DONE

Processar os AddOns - DONE

Pesquisar a ideia de dividir os AddOns - DONE

----------}
